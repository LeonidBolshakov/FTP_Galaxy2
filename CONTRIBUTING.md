# CONTRIBUTING.md

## Общие принципы

Данный проект разрабатывается с упором на:
- чистую архитектуру
- явное разделение ролей и реализаций
- слабую связность компонентов
- предсказуемые и читаемые соглашения

Код пишется на английском языке.  
Документация ведётся на русском языке для лучшего понимания и сопровождения.

---

## Архитектурный подход

В проекте используется:

- **структурная типизация** (`typing.Protocol`)
- **явное внедрение зависимостей** (Dependency Injection)
- отсутствие жёстких иерархий наследования без необходимости

`Protocol` используется для описания ролей компонентов, а конкретные классы — для реализации этих ролей.

---

## Соглашения по именованию сервисов и протоколов

### 1. Протоколы (интерфейсы)

Протоколы описывают **роль / ответственность компонента**  
и называются по принципу *«что делает компонент»*.

Пример:

```python
class DiffPlanner(Protocol):
    def run(self, data: DiffInput) -> DiffPlan: ...
```

Правила:
- используются существительные или существительные словосочетания
- **не используются** слова `Base`, `Impl`, `Interface`
- протоколы **не содержат реализации**
- протоколы не предназначены для наследования ради логики

Примеры протоколов:
- `ExecutionPolicy`
- `SnapshotService`
- `DiffPlanner`
- `TransferService`
- `RepositoryValidator`
- `ErrorHandler`

---

### 2. Реализация по умолчанию (`Default`)

Основная (каноническая) реализация протокола **обязана**
иметь префикс `Default`.

```python
class DefaultDiffPlanner:
    def run(self, data: DiffInput) -> DiffPlan:
        ...
```

Смысл `Default`:

> «реализация, используемая системой, если не указано иное»

`Default` **не означает**:
- «простая»
- «временная»
- «упрощённая»

Правила:
- у одного протокола должна быть **не более одной** реализации `Default`
- `DefaultX` считается основной и рекомендуемой реализацией

Примеры:
- `DefaultExecutionPolicy`
- `DefaultSnapshotService`
- `DefaultDiffPlanner`
- `DefaultTransferService`
- `DefaultRepositoryValidator`
- `DefaultErrorHandler`

---

### 3. Альтернативные реализации

Альтернативные реализации должны **явно отражать, чем они отличаются**
от реализации по умолчанию.

Имена должны описывать:
- алгоритм
- режим работы
- ограничение
- назначение

Примеры:
- `HashBasedDiffPlanner`
- `StrictRepositoryValidator`
- `DryRunTransferService`
- `ExperimentalExecutionPolicy`

Не рекомендуется использовать имена, намекающие на «качество»,
«сложность» или «временность»:

- ❌ `SimpleX`
- ❌ `BasicX`
- ❌ `MainX`
- ❌ `XImpl`

---

### 4. Заглушки, фейки и тестовые реализации

Специальные реализации должны иметь **явный префикс**,
однозначно указывающий на их назначение.

Используемые префиксы:

- `EmptyX` — пустая (no-op) реализация
- `FakeX` — тестовый двойник
- `StubX` — минимальная заглушка
- `DebugX` — вспомогательная реализация для отладки

Примеры:
- `EmptyDiffPlanner`
- `FakeSnapshotService`
- `StubTransferService`
- `DebugExecutionPolicy`

---

## Использование во внедрении зависимостей (DI)

Внедрение зависимостей должно происходить **через протоколы**,  
а не через конкретные классы.

Правильно:

```python
planner: DiffPlanner = DefaultDiffPlanner()
```

Неправильно:

```python
planner = DefaultDiffPlanner()
```

Это обеспечивает:
- слабую связность компонентов
- лёгкую замену реализаций
- прозрачные архитектурные границы
- простоту тестирования

---

## Заключение

Данные соглашения являются обязательными для всего нового кода.

Цели соглашений:
- единообразие проекта
- предсказуемость архитектуры
- отсутствие «временных» решений
- простота расширения без рефакторинга имён

Если возникает сомнение в именовании или архитектурном решении —
предпочтение отдаётся **явности, нейтральности и расширяемости**.
